package amf.core.internal.parser.domain

import amf.core.client.scala.model.domain.extensions.DomainExtension
import amf.core.client.scala.model.domain.{Annotation, EternalSerializedAnnotation, SerializableAnnotation}
import amf.core.internal.annotations.{
  AutoGeneratedName,
  DomainExtensionAnnotation,
  ExternalFragmentRef,
  Inferred,
  InferredProperty,
  InheritanceProvenance,
  InlineElement,
  LexicalInformation,
  ResolvedLinkAnnotation,
  ResolvedLinkTargetAnnotation,
  SourceNode,
  SourceYPart,
  SynthesizedField,
  TrackedElement,
  VirtualElement,
  SourceLocation => AmfSourceLocation
}
import org.mulesoft.common.client.lexical.{PositionRange, SourceLocation}
import org.yaml.model.{YMapEntry, YNode, YPart}

import scala.collection.mutable.ListBuffer

/** Element annotations
  */
class Annotations() {

  private var annotations: ListBuffer[Annotation] = new ListBuffer()

  def foreach(fn: Annotation => Unit): Unit = annotations.foreach(fn)

  def map(fn: Annotation => Annotation): Unit = annotations = annotations.map(fn)

  def find[T <: Annotation](fn: Annotation => Boolean): Option[T] = annotations.find(fn).map(_.asInstanceOf[T])

  def find[T <: Annotation](clazz: Class[T]): Option[T] = find(clazz.isInstance(_))

  def collect[T](pf: PartialFunction[Annotation, T]): Seq[T] = annotations.collect(pf)

  def contains[T <: Annotation](clazz: Class[T]): Boolean = annotations.exists(clazz.isInstance(_))

  def size: Int = annotations.size

  def sourceLocation: SourceLocation = {
    val sourceName = find(classOf[AmfSourceLocation]).map(_.location).getOrElse("")
    val range = find(classOf[LexicalInformation])
      .map(r => PositionRange(r.range.start.line, r.range.start.column, r.range.end.line, r.range.end.column))
      .getOrElse(PositionRange.ZERO)
    SourceLocation(sourceName, range)
  }

  def +=(annotation: Annotation): this.type = {
    annotations += annotation
    this
  }

  def ++=(other: Annotations): this.type = this ++= other.annotations

  def ++=(other: TraversableOnce[Annotation]): this.type = {
    annotations ++= other
    this
  }

  def reject(p: Annotation => Boolean): this.type = {
    annotations = annotations.filter(a => !p(a))
    this
  }

  /** Return SerializableAnnotations only. */
  def serializables(): Seq[SerializableAnnotation] = collect {
    case s: SerializableAnnotation if !s.isInstanceOf[EternalSerializedAnnotation] => s
  }

  /** Return EternalSerializedAnnotations only. */
  def eternals(): Seq[EternalSerializedAnnotation] = collect { case e: EternalSerializedAnnotation => e }

  def unapply[T <: Annotation](clazz: Class[T]): Option[T] = find(clazz)

  def copy(): Annotations = Annotations(this)

  def copyFiltering(filter: Annotation => Boolean): Annotations = Annotations() ++= annotations.filter(filter)

  def into(collector: ListBuffer[Annotation], filter: Annotation => Boolean): Annotations = {
    collector ++= annotations.filter(filter)
    this
  }

  def nonEmpty: Boolean = annotations.nonEmpty

  /** Client Methods */
  def lexical(): PositionRange = find(classOf[LexicalInformation]).map(_.range).getOrElse(PositionRange.NONE)

  def custom(): Seq[DomainExtension] = collect { case d: DomainExtensionAnnotation => d }.map(_.extension)

  def fragmentName(): Option[String] = find(classOf[ExternalFragmentRef]).map(_.fragment)

  def location(): Option[String] = find(classOf[AmfSourceLocation]).map(_.location)

  def isTrackedBy(trackId: String): Boolean =
    collect { case t: TrackedElement if t.parents.contains(trackId) => t }.nonEmpty

  def isTracked: Boolean = collect { case t: TrackedElement => t }.nonEmpty

  def resolvedLink: Option[String] = find(classOf[ResolvedLinkAnnotation]).map(_.linkId)

  def resolvedLinkTarget: Option[String] = find(classOf[ResolvedLinkTargetAnnotation]).map(_.linkTargetId)

  def inheritanceProvenance: Option[String] = find(classOf[InheritanceProvenance]).map(_.baseId)

  def inlinedElement: Boolean = find(classOf[InlineElement]).isDefined

  def autoGeneratedName: Boolean = find(classOf[AutoGeneratedName]).isDefined

  // This should be in amf-shapes BUT PropertyShape is in amf-core
  def isInferredProperty: Boolean = find(classOf[InferredProperty]).isDefined

  def clear() = annotations.clear()
}

object Annotations {

  def apply(): Annotations = new Annotations()

  def apply(annotations: Annotations): Annotations = {
    val result = new Annotations()
    result.annotations ++= annotations.annotations
    result
  }

  def apply(ast: YPart): Annotations = {
    val annotations = new Annotations() ++= Set(
        LexicalInformation(ast),
        SourceYPart(ast),
//      AmfSourceLocation(ast.sourceName))
        AmfSourceLocation(ast)
    )
    ast match {
      case node: YNode      => annotations += SourceNode(node)
      case entry: YMapEntry => annotations += SourceNode(entry.value)
      case _                => annotations
    }

  }

  // todo: temp method to keep compatibility against previous range serialization logic.
  // We should discuss if always use the range of the YNode, or always use the range of the Ynode member.
  def valueNode(node: YNode): Annotations = apply(node.value) += SourceNode(node)

  def apply(annotation: Annotation): Annotations       = new Annotations() += annotation
  def apply(annotations: Seq[Annotation]): Annotations = new Annotations() ++= annotations

  val empty: Annotations = new Annotations() {
    override def +=(annotation: Annotation): this.type              = this
    override def ++=(other: Annotations): this.type                 = this
    override def ++=(other: TraversableOnce[Annotation]): this.type = this
  }

  def inferred(): Annotations = apply(Inferred())

  def virtual(): Annotations = apply(VirtualElement())

  def synthesized(): Annotations = apply(SynthesizedField())
}
